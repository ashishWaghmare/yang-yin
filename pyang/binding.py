# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_cell_turing_machine__turing_machine_tape_cell(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module turing-machine - based on the path /turing-machine/tape/cell. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of non-blank cells.
  """
  __slots__ = ('_path_helper', '_extmethods', '__coord','__symbol',)

  _yang_name = 'cell'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__coord = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="coord", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='cell-index', is_config=False)
    self.__symbol = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), restriction_dict={'length': ['1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['turing-machine', 'tape', 'cell']

  def _get_coord(self):
    """
    Getter method for coord, mapped from YANG variable /turing_machine/tape/cell/coord (cell-index)

    YANG Description: Coordinate (index) of the tape cell.
    """
    return self.__coord
      
  def _set_coord(self, v, load=False):
    """
    Setter method for coord, mapped from YANG variable /turing_machine/tape/cell/coord (cell-index)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_coord is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_coord() directly.

    YANG Description: Coordinate (index) of the tape cell.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="coord", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='cell-index', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """coord must be of a type compatible with cell-index""",
          'defined-type': "turing-machine:cell-index",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="coord", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='cell-index', is_config=False)""",
        })

    self.__coord = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_coord(self):
    self.__coord = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="coord", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='cell-index', is_config=False)


  def _get_symbol(self):
    """
    Getter method for symbol, mapped from YANG variable /turing_machine/tape/cell/symbol (tape-symbol)

    YANG Description: Symbol appearing in the tape cell.

Blank (empty string) is not allowed here because the
'cell' list only contains non-blank cells.
    """
    return self.__symbol
      
  def _set_symbol(self, v, load=False):
    """
    Setter method for symbol, mapped from YANG variable /turing_machine/tape/cell/symbol (tape-symbol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_symbol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_symbol() directly.

    YANG Description: Symbol appearing in the tape cell.

Blank (empty string) is not allowed here because the
'cell' list only contains non-blank cells.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), restriction_dict={'length': ['1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """symbol must be of a type compatible with tape-symbol""",
          'defined-type': "turing-machine:tape-symbol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), restriction_dict={'length': ['1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=False)""",
        })

    self.__symbol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_symbol(self):
    self.__symbol = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), restriction_dict={'length': ['1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=False)

  coord = __builtin__.property(_get_coord)
  symbol = __builtin__.property(_get_symbol)


  _pyangbind_elements = OrderedDict([('coord', coord), ('symbol', symbol), ])


class yc_tape_turing_machine__turing_machine_tape(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module turing-machine - based on the path /turing-machine/tape. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The contents of the tape.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cell',)

  _yang_name = 'tape'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cell = YANGDynClass(base=YANGListType("coord",yc_cell_turing_machine__turing_machine_tape_cell, yang_name="cell", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='coord', extensions=None), is_container='list', yang_name="cell", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['turing-machine', 'tape']

  def _get_cell(self):
    """
    Getter method for cell, mapped from YANG variable /turing_machine/tape/cell (list)

    YANG Description: List of non-blank cells.
    """
    return self.__cell
      
  def _set_cell(self, v, load=False):
    """
    Setter method for cell, mapped from YANG variable /turing_machine/tape/cell (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cell is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cell() directly.

    YANG Description: List of non-blank cells.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("coord",yc_cell_turing_machine__turing_machine_tape_cell, yang_name="cell", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='coord', extensions=None), is_container='list', yang_name="cell", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cell must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("coord",yc_cell_turing_machine__turing_machine_tape_cell, yang_name="cell", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='coord', extensions=None), is_container='list', yang_name="cell", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='list', is_config=False)""",
        })

    self.__cell = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cell(self):
    self.__cell = YANGDynClass(base=YANGListType("coord",yc_cell_turing_machine__turing_machine_tape_cell, yang_name="cell", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='coord', extensions=None), is_container='list', yang_name="cell", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='list', is_config=False)

  cell = __builtin__.property(_get_cell)


  _pyangbind_elements = OrderedDict([('cell', cell), ])


class yc_input_turing_machine__turing_machine_transition_function_delta_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module turing-machine - based on the path /turing-machine/transition-function/delta/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Input parameters (arguments) of the transition rule.
  """
  __slots__ = ('_path_helper', '_extmethods', '__state','__symbol',)

  _yang_name = 'input'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=True)
    self.__symbol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['turing-machine', 'transition-function', 'delta', 'input']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /turing_machine/transition_function/delta/input/state (state-index)

    YANG Description: Current state of the control unit.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /turing_machine/transition_function/delta/input/state (state-index)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Current state of the control unit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with state-index""",
          'defined-type': "turing-machine:state-index",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=True)


  def _get_symbol(self):
    """
    Getter method for symbol, mapped from YANG variable /turing_machine/transition_function/delta/input/symbol (tape-symbol)

    YANG Description: Symbol read from the tape cell.
    """
    return self.__symbol
      
  def _set_symbol(self, v, load=False):
    """
    Setter method for symbol, mapped from YANG variable /turing_machine/transition_function/delta/input/symbol (tape-symbol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_symbol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_symbol() directly.

    YANG Description: Symbol read from the tape cell.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """symbol must be of a type compatible with tape-symbol""",
          'defined-type': "turing-machine:tape-symbol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=True)""",
        })

    self.__symbol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_symbol(self):
    self.__symbol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=True)

  state = __builtin__.property(_get_state, _set_state)
  symbol = __builtin__.property(_get_symbol, _set_symbol)


  _pyangbind_elements = OrderedDict([('state', state), ('symbol', symbol), ])


class yc_output_turing_machine__turing_machine_transition_function_delta_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module turing-machine - based on the path /turing-machine/transition-function/delta/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Output values of the transition rule.
  """
  __slots__ = ('_path_helper', '_extmethods', '__state','__symbol','__head_move',)

  _yang_name = 'output'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=True)
    self.__symbol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=True)
    self.__head_move = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'left': {}, 'right': {}},), default=six.text_type("right"), is_leaf=True, yang_name="head-move", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='head-dir', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['turing-machine', 'transition-function', 'delta', 'output']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /turing_machine/transition_function/delta/output/state (state-index)

    YANG Description: New state of the control unit. If this leaf is not
present, the state doesn't change.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /turing_machine/transition_function/delta/output/state (state-index)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: New state of the control unit. If this leaf is not
present, the state doesn't change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with state-index""",
          'defined-type': "turing-machine:state-index",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=True)


  def _get_symbol(self):
    """
    Getter method for symbol, mapped from YANG variable /turing_machine/transition_function/delta/output/symbol (tape-symbol)

    YANG Description: Symbol to be written to the tape cell. If this leaf is
not present, the symbol doesn't change.
    """
    return self.__symbol
      
  def _set_symbol(self, v, load=False):
    """
    Setter method for symbol, mapped from YANG variable /turing_machine/transition_function/delta/output/symbol (tape-symbol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_symbol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_symbol() directly.

    YANG Description: Symbol to be written to the tape cell. If this leaf is
not present, the symbol doesn't change.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """symbol must be of a type compatible with tape-symbol""",
          'defined-type': "turing-machine:tape-symbol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=True)""",
        })

    self.__symbol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_symbol(self):
    self.__symbol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..1']}), is_leaf=True, yang_name="symbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='tape-symbol', is_config=True)


  def _get_head_move(self):
    """
    Getter method for head_move, mapped from YANG variable /turing_machine/transition_function/delta/output/head_move (head-dir)

    YANG Description: Move the head one cell to the left or right
    """
    return self.__head_move
      
  def _set_head_move(self, v, load=False):
    """
    Setter method for head_move, mapped from YANG variable /turing_machine/transition_function/delta/output/head_move (head-dir)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_head_move is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_head_move() directly.

    YANG Description: Move the head one cell to the left or right
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'left': {}, 'right': {}},), default=six.text_type("right"), is_leaf=True, yang_name="head-move", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='head-dir', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """head_move must be of a type compatible with head-dir""",
          'defined-type': "turing-machine:head-dir",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'left': {}, 'right': {}},), default=six.text_type("right"), is_leaf=True, yang_name="head-move", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='head-dir', is_config=True)""",
        })

    self.__head_move = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_head_move(self):
    self.__head_move = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'left': {}, 'right': {}},), default=six.text_type("right"), is_leaf=True, yang_name="head-move", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='head-dir', is_config=True)

  state = __builtin__.property(_get_state, _set_state)
  symbol = __builtin__.property(_get_symbol, _set_symbol)
  head_move = __builtin__.property(_get_head_move, _set_head_move)


  _pyangbind_elements = OrderedDict([('state', state), ('symbol', symbol), ('head_move', head_move), ])


class yc_delta_turing_machine__turing_machine_transition_function_delta(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module turing-machine - based on the path /turing-machine/transition-function/delta. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The list of transition rules.
  """
  __slots__ = ('_path_helper', '_extmethods', '__label','__input','__output',)

  _yang_name = 'delta'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__label = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='string', is_config=True)
    self.__input = YANGDynClass(base=yc_input_turing_machine__turing_machine_transition_function_delta_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)
    self.__output = YANGDynClass(base=yc_output_turing_machine__turing_machine_transition_function_delta_output, is_container='container', yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['turing-machine', 'transition-function', 'delta']

  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /turing_machine/transition_function/delta/label (string)

    YANG Description: An arbitrary label of the transition rule.
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /turing_machine/transition_function/delta/label (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: An arbitrary label of the transition rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='string', is_config=True)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='string', is_config=True)


  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /turing_machine/transition_function/delta/input (container)

    YANG Description: Input parameters (arguments) of the transition rule.
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /turing_machine/transition_function/delta/input (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: Input parameters (arguments) of the transition rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_turing_machine__turing_machine_transition_function_delta_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_input_turing_machine__turing_machine_transition_function_delta_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_turing_machine__turing_machine_transition_function_delta_input, is_container='container', yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /turing_machine/transition_function/delta/output (container)

    YANG Description: Output values of the transition rule.
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /turing_machine/transition_function/delta/output (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.

    YANG Description: Output values of the transition rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_turing_machine__turing_machine_transition_function_delta_output, is_container='container', yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_output_turing_machine__turing_machine_transition_function_delta_output, is_container='container', yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_turing_machine__turing_machine_transition_function_delta_output, is_container='container', yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)

  label = __builtin__.property(_get_label, _set_label)
  input = __builtin__.property(_get_input, _set_input)
  output = __builtin__.property(_get_output, _set_output)


  _pyangbind_elements = OrderedDict([('label', label), ('input', input), ('output', output), ])


class yc_transition_function_turing_machine__turing_machine_transition_function(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module turing-machine - based on the path /turing-machine/transition-function. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The Turing Machine is configured by specifying the
transition function.
  """
  __slots__ = ('_path_helper', '_extmethods', '__delta',)

  _yang_name = 'transition-function'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__delta = YANGDynClass(base=YANGListType("label",yc_delta_turing_machine__turing_machine_transition_function_delta, yang_name="delta", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='label', extensions=None), is_container='list', yang_name="delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['turing-machine', 'transition-function']

  def _get_delta(self):
    """
    Getter method for delta, mapped from YANG variable /turing_machine/transition_function/delta (list)

    YANG Description: The list of transition rules.
    """
    return self.__delta
      
  def _set_delta(self, v, load=False):
    """
    Setter method for delta, mapped from YANG variable /turing_machine/transition_function/delta (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_delta is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_delta() directly.

    YANG Description: The list of transition rules.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("label",yc_delta_turing_machine__turing_machine_transition_function_delta, yang_name="delta", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='label', extensions=None), is_container='list', yang_name="delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """delta must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("label",yc_delta_turing_machine__turing_machine_transition_function_delta, yang_name="delta", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='label', extensions=None), is_container='list', yang_name="delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='list', is_config=True)""",
        })

    self.__delta = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_delta(self):
    self.__delta = YANGDynClass(base=YANGListType("label",yc_delta_turing_machine__turing_machine_transition_function_delta, yang_name="delta", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='label', extensions=None), is_container='list', yang_name="delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='list', is_config=True)

  delta = __builtin__.property(_get_delta, _set_delta)


  _pyangbind_elements = OrderedDict([('delta', delta), ])


class yc_turing_machine_turing_machine__turing_machine(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module turing-machine - based on the path /turing-machine. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data and configuration of a Turing Machine.
  """
  __slots__ = ('_path_helper', '_extmethods', '__state','__head_position','__tape','__transition_function',)

  _yang_name = 'turing-machine'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=False)
    self.__head_position = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="head-position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='cell-index', is_config=False)
    self.__tape = YANGDynClass(base=yc_tape_turing_machine__turing_machine_tape, is_container='container', yang_name="tape", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)
    self.__transition_function = YANGDynClass(base=yc_transition_function_turing_machine__turing_machine_transition_function, is_container='container', yang_name="transition-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['turing-machine']

  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /turing_machine/state (state-index)

    YANG Description: Current state of the control unit.

The initial state is 0.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /turing_machine/state (state-index)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Current state of the control unit.

The initial state is 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with state-index""",
          'defined-type': "turing-machine:state-index",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='state-index', is_config=False)


  def _get_head_position(self):
    """
    Getter method for head_position, mapped from YANG variable /turing_machine/head_position (cell-index)

    YANG Description: Position of tape read/write head.
    """
    return self.__head_position
      
  def _set_head_position(self, v, load=False):
    """
    Setter method for head_position, mapped from YANG variable /turing_machine/head_position (cell-index)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_head_position is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_head_position() directly.

    YANG Description: Position of tape read/write head.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="head-position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='cell-index', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """head_position must be of a type compatible with cell-index""",
          'defined-type': "turing-machine:cell-index",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="head-position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='cell-index', is_config=False)""",
        })

    self.__head_position = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_head_position(self):
    self.__head_position = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="head-position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='cell-index', is_config=False)


  def _get_tape(self):
    """
    Getter method for tape, mapped from YANG variable /turing_machine/tape (container)

    YANG Description: The contents of the tape.
    """
    return self.__tape
      
  def _set_tape(self, v, load=False):
    """
    Setter method for tape, mapped from YANG variable /turing_machine/tape (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tape is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tape() directly.

    YANG Description: The contents of the tape.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tape_turing_machine__turing_machine_tape, is_container='container', yang_name="tape", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tape must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tape_turing_machine__turing_machine_tape, is_container='container', yang_name="tape", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)""",
        })

    self.__tape = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tape(self):
    self.__tape = YANGDynClass(base=yc_tape_turing_machine__turing_machine_tape, is_container='container', yang_name="tape", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)


  def _get_transition_function(self):
    """
    Getter method for transition_function, mapped from YANG variable /turing_machine/transition_function (container)

    YANG Description: The Turing Machine is configured by specifying the
transition function.
    """
    return self.__transition_function
      
  def _set_transition_function(self, v, load=False):
    """
    Setter method for transition_function, mapped from YANG variable /turing_machine/transition_function (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transition_function is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transition_function() directly.

    YANG Description: The Turing Machine is configured by specifying the
transition function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transition_function_turing_machine__turing_machine_transition_function, is_container='container', yang_name="transition-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transition_function must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transition_function_turing_machine__turing_machine_transition_function, is_container='container', yang_name="transition-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)""",
        })

    self.__transition_function = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transition_function(self):
    self.__transition_function = YANGDynClass(base=yc_transition_function_turing_machine__turing_machine_transition_function, is_container='container', yang_name="transition-function", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)

  state = __builtin__.property(_get_state)
  head_position = __builtin__.property(_get_head_position)
  tape = __builtin__.property(_get_tape, _set_tape)
  transition_function = __builtin__.property(_get_transition_function, _set_transition_function)


  _pyangbind_elements = OrderedDict([('state', state), ('head_position', head_position), ('tape', tape), ('transition_function', transition_function), ])


class turing_machine(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module turing-machine - based on the path /turing-machine. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data model for the Turing Machine.
  """
  __slots__ = ('_path_helper', '_extmethods', '__turing_machine',)

  _yang_name = 'turing-machine'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__turing_machine = YANGDynClass(base=yc_turing_machine_turing_machine__turing_machine, is_container='container', yang_name="turing-machine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_turing_machine(self):
    """
    Getter method for turing_machine, mapped from YANG variable /turing_machine (container)

    YANG Description: State data and configuration of a Turing Machine.
    """
    return self.__turing_machine
      
  def _set_turing_machine(self, v, load=False):
    """
    Setter method for turing_machine, mapped from YANG variable /turing_machine (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_turing_machine is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_turing_machine() directly.

    YANG Description: State data and configuration of a Turing Machine.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_turing_machine_turing_machine__turing_machine, is_container='container', yang_name="turing-machine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """turing_machine must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_turing_machine_turing_machine__turing_machine, is_container='container', yang_name="turing-machine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)""",
        })

    self.__turing_machine = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_turing_machine(self):
    self.__turing_machine = YANGDynClass(base=yc_turing_machine_turing_machine__turing_machine, is_container='container', yang_name="turing-machine", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.net/turing-machine', defining_module='turing-machine', yang_type='container', is_config=True)

  turing_machine = __builtin__.property(_get_turing_machine, _set_turing_machine)


  _pyangbind_elements = OrderedDict([('turing_machine', turing_machine), ])


